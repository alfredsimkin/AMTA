The original input files are:
1. A list of all Refseq gene annotations from UCSC in BED format
2. A large sequence alignment file aligning every part of the gorilla genome 
to 10 other primates, downloaded from UCSC in MAF format
3. individual primate genomes for five species

The core of my analysis is done using two publicly available programs, 
called lastz (used to compare genomes against each other) and dnaml (used to 
reconstruct hypothetical ancestral DNA sequences from living primate 
descendants)

There are about 19 scripts needed to get my main results, but each one is 
usually only about 30 lines. They're named:
custom.py
coordinate_converter.py
remove_non_seq.py
filter_for_all_species.py
extract_only_all_species.py
index_all_chunks.py
sort_indexed.py
make_first_lastz_scripts.py
join_result_files.py
parse_results.py
merge_them.py
get_lastz_hits.py
final_filter.py
remove_gaps.py
collect_ancestors.py
count_gains_losses.py
distributions_by_eightmer.py
distribution_sums.py
nearest_neighbor_values.py

coordinate_converter.py operates on the BED formatted file from UCSC to get 
rid of extra potentially problematic genes (such as noncoding genes like 
tRNAs, genes without 3' UTRs, genes with multiple 3' UTR exons, genes which 
are annotated with the same name in multiple places in the genome, and genes 
on a single chromosome where the chromosome has been given multiple names) 
and extracts 3' UTR coordinates for genes that pass the filters.

remove_non_seq.py functions on the UCSC maf files, and trims lines that 
aren't sequence

filter_for_all_species.py operates on the trimmed maf files, removing maf 
entries that have missing species from the 5 primate species I'm looking at.

extract_only_all_species.py creates a new maf file consisting only of the 
maf entries found by filter_for_all_species.py

index_all_chunks.py uses the maf file generated with 
extract_only_all_species.py. The output is a list of MAF entries, their byte 
counts, and their coordinates (relative to the positive strand as BED does 
rather than the current strand as MAF does) in each species.

sort_indexed.py sorts the results of index_all_chunks.py relative to the 
human genome, from low chromosome number to high chromosome number, and from 
low start coordinate to high start coordinate

make_first_lastz_scripts.py operates on the genomes downloaded from UCSC. 
The program is designed to exist in a folder with fasta files of a 
particular primate genome. Since I analyze five primate genomes, there are 
five identical copies of the script, in five folders. Each folder contains a 
genome, separated, if needed, into separate manageably sized fasta files 
(which can each have individual chromosomes or multiple chromosomes/contigs) 
Using a file with a list of the names of these fasta files 
(chromosome_list), this program creates a set of lastz commands for each 
genome, which can be run in parallel or serially.

At this point, a list of fasta_formatted human refseq genes which passed the 
filters of coordinate_converter.py is downloaded twice from UCSC, once with 
all exons (both protein coding and UTR) in uppercase, and once with proein 
coding exons in uppercase and UTR exons in lowercase. lastz is run to 
compare the file with all exons in uppercase to the fasta files making up 
each primate genome.

After running these lastz commands on each fasta file of a genome, 
join_result_files.py joins the output from each lastz run into one result 
file, so that each genome has a separate, single result file.

parse_results.py goes through the result file generated by 
join_result_files.py (stored as a set of statistics for each alignment) and 
organizes the alignments into putative transcripts. This program removes 
alignments that have below 95% identity to the human subject sequences, and 
considers transcripts to be those alignments which fall on the same strand 
of the same chromosome, and which match the chromosome in the same order as 
the searched subject gene (i.e. if part of exon 3 matches genomic position 
10 of the positive strand of chromosome 1, the next hit, to a higher 
position on the positive strand of chromosome 1, should be to exon 4 or a 
subsequent position in exon 3, and not exon 2). These multiple 
'transcript' alignments are then ranked by total percent of subject gene 
sequence covered. Only those which cumulatively cover more than 80% of the 
subject human gene are included. Of these, only those which have a second 
best hit that covers less than 20% of the material covered by the best hit 
are considered. Of this set, only those having less than 20% of their 
subject sequence covered redundantly by the alignments are considered, and 
finally, the transcript is compared to the UCSC file with UTR exons in 
lowercase to remove any transcripts which cover any 3' UTR basepairs 
redundantly. The protein coding genes which remain after these filters are 
written to a dictionary.

merge_them.py takes the output dictionaries from each genome created by 
parse_results.py, and intersects them with each other. The result is a 
list of putatively non-duplicated genes with high confidence of homology 
to the human genome across all primates.

get_lastz_hits.py filters the output of coordinate_converter.py to only 
list results retrieved by merge_them.py.

final_filter.py takes the list of genes retrieved by get_lastz_hits.py, 
the maf entries from extract_only_all_species.py, and the summaries from 
extract_only_all_species.py, filters out any maf entries that overlap the 
3' UTRs redundantly or change their strand of homology within the same 
protein coding gene, pieces together the sequence corresponding to these 
3' UTRs covered by these maf entries (with 5 N's inserted between 
nonadjacent regions of 3' UTR), and runs dnaml on the results (using 
collect_ancestors.py to store the dnaml results in a dictionary and verify 
that the tree topology is consistent across dnaml runs)

remove_gaps.py replaces runs of one or more ambiguous nucleotides in one 
or more lineages with a single ambiguous nucleotide in all lineages. This 
is done to ensure that only those 8mers which are unambiguous in all 
lineages are analyzed.

count_gains_losses.py uses the output dictionary from remove_gaps.py to 
count how many times every 8mer within every species is present, gained, 
and lost within every gene. The dictionary is populated by genes, which 
are each a dictionary of species, which are each a dictionary of 
eightmers, each of which is a 3 number summary list: number of times the 
eightmer is present in that species in that gene, number of times the 
eightmer is gained in that species in that gene, and number of times the 
eightmer is lost in that species in that gene. Because such a dictionary 
would be much larger than the available memory, when calculated across the 
entire list of protein coding genes, multiple dictionaries of 100 genes 
each are created.

distributions_by_eightmer.py counts the number of times every 3 number 
summary occurred across genes. Because this is just a count of 3 number 
summaries that is added up across all genes, all output dictionaries of 
count_gain_losses.py can be stored in a single file. The output is a 
dictionary of eightmers, each of which has a dictionary of species, each 
of which has dictionary of all 3 number summaries and a count of how many 
genes had each 3 number summary.

distribution_sums.py has two outputs. The first is a sum of total sites, 
gains, and losses within each species for each eightmer. The second is a 
sum of total sites, gains and losses summed across species for each 
eightmer.

nearest_neighbor_values.py takes the second output of distribution_sums.py 
and uses it to rank each eightmer's gain and loss rates relative to those 
of all eightmers one mutational step away.
